<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="apple-touch-icon" href="/assets/icons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png"><link rel="icon" href="/assets/icons/favicon.ico"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="/assets/css/post.css"><title>How to paint a webpage faster?</title><meta name="description" content="Measuring the time it takes for the web page&#39;s content to reach your eyes."><script type="application/ld+json">{
        "description": "Measuring the time it takes for the web page&#39;s content to reach your eyes.",
        "author": { "@type": "Person", "name": "Tumulty Web Services, LLC" },
        "@type": "BlogPosting",
        "url": "https://tumultywebservices.dev",
        "publisher": {
          "@type": "Organization",
          "logo": {
            "@type": "ImageObject",
            "url": "/assets/images/logo.png"
          },
          "name": "Tumulty Web Services, LLC"
        },
        "headline": "How to paint a webpage faster?",
        "datePublished": "2021-01-10T00:00:00.000Z",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://tumultywebservices.dev"
        },
        "@context": "http://schema.org"
      }</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-16S4TT058B"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());    
      gtag('config', 'G-16S4TT058B');</script></head><body class="antialiased text-gray-700"><div class="max-w-screen-lg xl:max-w-screen-xl mx-auto"><header class="mt-2 pb-2"><div class="flex flex-col md:flex-row"><a href="/"><img src="/assets/images/tws-logo.png" width="32" height="38" class="ml-2 mr-1 md:ml-4" alt="Tumulty Web Services"></a><div class="mx-0 my-2 md:w-3/5"><h1 class="text-1xl font-black mx-2 md:mx-0">Tumulty Web Services</h1></div><div class="my-2"><a href="tel:9083311057" class="ml-2 md:ml-0 block md:inline-block mr-1 text-green-800 font-black text-sm">908-331-1057</a> <a href="mail:tumultywebservices@gmail.com" class="ml-2 md:ml-0 block md:inline-block mr-1 text-green-800 font-black text-sm">tumultywebservices@gmail.com</a> <a href="#form" class="max-btn-width text-center ml-2 my-2 md:ml-0 md:my-0 block md:inline-block text-1xl font-black text-white bg-gradient-to-t from-green-700 to-green-600 hover:bg-green-500 hover:from-green-500 px-2 py-1 rounded">Get in touch</a></div></div></header></div><div class="max-w-screen-md mx-auto"><article class="my-10"><header><h1 class="text-center font-bold text-8xl my-5 text-gray-800">How to paint a webpage faster?</h1><div class="text-center text-base lg:text-xl mb-8">January 9, 2021</div></header><section class="content"><h2>Waiting for a webpage to load is the worst.</h2><p><img src="/assets/images/paint-a-webpage.jpg" alt="paint a webpage"></p><p><em>Before you begin reading, the following article has two purposes, the first being to share with site owners how Google helps them improve the performance of their website and the second as a way for me (Peter Tumulty) to learn these tools/metrics in-depth. This post is an analysis, re-wording, study, and interpretation of the article on <a href="https://web.dev">Web.dev</a> <a href="https://web.dev/optimize-lcp/">Optimize Largest Contentful Paint</a>. I'm not trying to pass off their documentation as my own content. I'm a student of the web and these are my learnings.</em></p><p>Some may think it's important to consider how long it takes for a page to load when improving a web page's load speed. However, if you start digging around underneath the hood of a web page, you'll soon discover it's more important to look at the rate at which the largest piece of content (usually a banner image or video) hits the page.</p><p>The Largest Contentful Paint (LCP) is the name of one of the Core Web Vitals provided by Google to measure when that largest piece of content renders in the viewport—assuming that the largest content by size is the most important. Measuring the LCP can determine when the main content of the page has finished loading.</p><p><strong>Causes of slow LCP loading times</strong></p><ul><li>Server response time</li><li>Loading JavaScript &amp; CSS files that can break the flow of the page loading</li><li>Site resources</li><li>Items rendering only in the browser</li></ul><h3>Server response time</h3><p>The time it takes for the browser to request content from the server can impact how fast that content reaches the viewport.</p><p>Google has labeled this process server-to-browser request for content, Time to First Byte, and there are different ways of measuring this metric:</p><ul><li>Make sure your not asking the server for crazy-large requests</li><li>Serve static assest on a Content Delivery Network</li><li>Set up headers to cache assets in the browser</li><li>Make sure you allow HTML pages to cache in the browser</li><li>Make sure if you are loading JQuery, Bootstrap.css, or Google Analytics on a page, they hit the browser first.</li></ul><h4>Server Optimization</h4><p>Before we can optimize browser resources for performance, we need to optimize how these resources are requested. How long does it take a long time for the server to return with the web page's assets? You generally know if it is taking a long time if you are staring at a white screen with a loader icon in the browser tab. You won't even begin to see a spinning loader icon on the page. If the page resources are taking a long time coming from the server.</p><p>If you happen to know and work closely with your site's backend engineer, you may want to ask them if there are complicated server-side operations for such and such a page. They might be able to tell you whether the code is optimized for delivering to the client.</p><p>Because if we want to optimize a web page's performance, we need to get the horse before the carriage.</p><p>The page's resources must be hitting the browser in milliseconds before we can start designing our web page to improve its LCP.</p><p>Many Content Management Systems, like WordPress, don't server up static pages (like the ones you built-in high-school) but require server-side code to create web pages dynamically. To me, these CMS are like short-order cooks who put together your meal on request.</p><p>The steps of this web page rendering process go as followed:</p><ol><li>User requests a web page through the browser</li><li>The request is sent to the server</li><li>The server uses server-side code and complex logic to put the page's content together</li><li>The server then sends the results back the user's computer</li><li>The browser begins rendering the request on the screen.</li></ol><p>Ensuring that steps 2 and 3 are running smoothly is the first step in optimizing the LCP of a web page.</p><h4>Using a Content Delivery Network (CDN)</h4><p>A CDN is an interconnected network of servers that are all located in different areas. If you host your site on a CDN, the content is delivered to the user from a server potentially closer to their location. If a site is hosted on a single server than the user must be closer to the server to improve the requested speed.</p><h4>Caching Site Asseets</h4><p>Many websites have a contact page containing some paragraphs of text and a form, not much changes on this page. If your site has one of these pages, then it's a good idea to store this page in the server cache to reduce the Time To First Byte.</p><p>You can also apply server caching by doing the following:</p><ul><li>Set up a reverse proxy to serve cached content and act as a middle man between the user and the server</li><li>Cloud providers like Firebase, AWS, and Azure have settings for caching</li><li>If you are using a CDN make sure that edge servers are provided. So you can save assets on a server closer to your user</li></ul><h4>Serve HTML pages cache-first</h4><p>You can add an under-the-hood butler to your website, a small snippet of code that runs in the background and conduct how requests are intercepted and served, called a service-worker. You can use this service-worker to programmatically control caching and make it possible for the page's HTML content to render the same file again and again, and only update it when there is a change to the file.</p><h4>Establishing third-party connections early</h4><p>Requesting resources from the server, as you can see, its a pretty big job. By adding requests for resources from another server, you are adding a new layer of complexity. To prevent things from getting further complicated, you can set the link to that resource with a &quot;preconnect&quot; or &quot;DNS-prefetch&quot; relation value. In code, it'll look something like this...</p><pre><code>&lt;head&gt;
  …
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://bootstrap-resource-CDN-link....&quot;&gt;
  &lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://some-resource-coming-from-a-3rd-party...&quot;&gt;
&lt;/head&gt;
</code></pre><p>The <code>rel=&quot;preconnect&quot;</code> attribute will tell the servers to make this resource a priority and get it <strong>As Soon As Possible.</strong></p><h3>Rendering blocking JS &amp; CSS</h3><p>The way the browser handles the loading of any page is that it starts with HTML first. It looks to the HTML to build out the page's structure (and to create the DOM tree). However, this process stops when the parser encounters an external stylesheet or JavaScript.</p><p>These scripts and stylesheets block the resources' rendering and delay the First Content Paint, which by extension, delays the Largest Contentful Paint. So the strategy to fix this issue is by setting a tag that will push any non-essential CSS and JS to the bottom of the page.</p><p>These are the three key ways to reduce the impact of render blocking CSS</p><ul><li>Minimize your CSS files</li></ul><p>When a coder writes CSS, they'll add spacing and indentation, and comments to make it easier to remove. However, these characters aren't necessary for parsers to understand. So you can set up a production-optimization tool to remove anything that makes CSS human-readable when sending it to your hosting. So when the parser reads your CSS, it's a single giant line of text.</p><ul><li><p>Optimize your CSS files</p><ul><li>Remove any unused CSS from the stylesheet</li><li>If CSS that is not need on one page, but needed on another, create a spearte CSS file and it it there.</li><li>Defer any unncessary CSS for initial rendering by loading the files one at a time using the rel=&quot;preload&quot; attribute.</li></ul></li><li><p>Make any essential CSS load inside the HTML file and at the top</p></li></ul><p>If there is some styling that needs to be loaded quickly and as soon as possible. Break it out of a style sheet and drop it in in the <code>&lt;head&gt;</code> tag. Inlining necessary CSS removes the server-request for this resource.</p><ul><li>Reduce JavaScript blocking time</li></ul><p>JavaScript makes web pages awesome! However, all that awesomeness comes at a cost. Reducing the amount of JavaScript you run on the page can result in better LCP times.</p><p>You would treat these JavaScript files the same as CSS files.</p><p>Ensure they are minimized, production-optimized (one line and no comments), defer the unnecessary stuff to the bottom, and use polyfills (bits of code that make your JS adaptable to different browsers).</p><h3>Slow Resource load times</h3><p>Although an increase in CSS or JavaScript-blocking time will directly result in worse performance, the time it takes to load many other types of resources can also affect paint times. The types of elements that affect LCP are:</p><p>JavaScript &amp; CSS are two significant factors the result in a worse LCP performance. However, it's also important to know that some HTML elements do too.</p><ul><li><code>&lt;img&gt;</code> elements</li><li><code>&lt;image&gt;</code> elements inside an <code>&lt;svg&gt;</code> element</li><li><code>&lt;video&gt;</code> elements</li></ul><p>We can't live in a world without images or videos on a web page. So here are a few ways to handle these elements to improve your LCP.</p><ul><li>Compress images</li><li>Preload the sources for these elements</li><li>Compress text files</li><li>Cache theses assets using a service worker</li></ul><h4>Optimizing images</h4><p>Almost every website on the internet trying to market services uses large hero banner images for advertising. These banners are above the fold, and the first thing the users sees.</p><p>These banner images are nice to see. However, they are the biggest factor in killing the LCP metric.</p><p>Here are a few tips on how to load that banner image without totally killing the page's LCP metric.</p><ul><li>Compress the image. Check out <a href="https://compressor.io">Compressor.io</a></li><li>Covert those images to a modern web-image format (JPEG 2000, JPEG XR, WebP)</li><li>Make sure these images are responsive</li><li>Consider using a image optimization CDN service like <a href="https://cloudinary.com">Cloudinary</a></li></ul><h4>Preload these resources</h4><p>Sometimes when a page loads, you'll see a bit of text, but during the load process, the font or the style of the text will change. That's because the text loaded first, and the stylesheet or font library loaded after the text.</p><p>Thankfully, this is a way to prioritize a stylesheet or a font during the page load process. You can apply the <code>rel=&quot;preload&quot;</code> attribute to the resource link to tell the browser, &quot;Hey, these are more important to load first before anything else.&quot;</p><p><strong>It'll look something like this in your code</strong></p><p><code>&lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;</code></p><h4>Compress your resources</h4><p>Another way to improve the request for resources to build a webpage is by compressing the request files. You can reduce the size of your HTML, CSS, and JS files with two compression algorithms that are configurable with a web server.</p><p>Two web server compression algorithms</p><ol><li><strong>GZip compression</strong></li><li><strong>Brotli</strong></li></ol><p>Configuring your webserver to use these algorithms to compress resources before sending them will minimize each file's size. If the server sends a small file, then the LCP metric improves.</p><p>There is some good news for site owners. Many hosting companies configure their web servers to use either GZip or Brotli already. However, if you need to configure the webserver yourself, it is recommended by Google to use <a href="https://blog.bitsrc.io/gzip-to-brotli-better-frontend-load-performance-b2b4d8dbf60f">Brotli over GZip since it provides better ratios for compression</a>. Suppose you have to select o a compression algorithm yourself. Ensure the resources are compressed beforehand and stored on the server if you can't compress them beforehand. They'll be compressed on request, and that adds another layer of complexity to the request and can impact the time for the request to be fulfilled.</p><h4>Dynamically serve resources</h4><p>To better control how to serve assets, you can set up conditional requests for those resources. You would want to set up conditional requests based on the user's network speed or device type.</p><p>When loading resources that make up the main content of a page, it can be effective to conditionally fetch different assets depending on the user's device or network conditions.</p><p>A real-world example of this is if you have a large banner image for your marketing website, and you want it to load without affecting your LCP. You can use conditional requests to ask for different banner sizes depending on the device viewport size or network type.</p><p>Baked into the browser are the following Web APIs to help you delegate requests depending on different screen sizes or network.</p><p>A list of useful properties that you can use:</p><ul><li><code>navigator.connection.effectiveType</code> checks for connecton type</li><li><code>navigator.connection.saveData</code> checks if a data-saver is enabled or disabled</li><li><code>navigator.hardwareConcurrency</code> checks the computer's CPU core count (wow that is some low-level information)</li><li><code>navigator.deviceMemory</code> checks what the memory of the current device</li></ul><p>Its safe to say, that the browser has a lot of tools to learn about your computer.</p><h4>In comes service workers...</h4><p>We now know there are some Web APIs that can gain useful information about the user's computer. We can use those Web APIs to dynamic serve resources depending on the user's device or network.</p><p><strong>But how do we actually use these Web APIs?</strong></p><p>We can use JavaScript to write what is known as a service worker. A service worker is a small script that handles tasks like caching static resources, serving them up from the browser rather than the network, and reducing requests to the server.</p><p>Service workers can also cache resources before the page finishes loading. When the user revisits the web page, the time those resources take to load is drastically reduced. If you want to learn more about Service Workers, I would check out a <a href="https://developers.google.com/web/tools/workbox">service worker library created by Google called Workbox</a>.</p><h3>Asking for resources after the page loads (Client-side rendering)</h3><p>Enormous percentages of websites these days use JavaScript. You have heard of the JavaScript framework wars Facebook's React.js vs. Google's Angular.js. The benefit of building webpages using one of these frameworks allows you to handle different parts of the web page using the browser instead of the server.</p><p>The drawback to using one of these JavaScript frameworks is that it can affect the LCP metric. Remember how we talked about how the size of the JS file can slow down your site. Well, if your webpage is built using a JS framework, that's a lot of JavaScript.</p><p>There are a few ways to optimize your website if it's using a JS framework.</p><ul><li>As always, minimize your JS files</li><li>Use server-side rendering (bring some of that JS could back into the server)</li><li>Use pre-rendering. Accordign to <a href="https://www.netlify.com/blog/2016/11/22/prerendering-explained/">netlify.com</a>, &quot;Prerendering is a process to preload all elements on the page in preparation for a web crawler to see it.&quot;</li></ul><h4>What's server-side rendering?</h4><p>The goal of JavaScript is to use as little as possible. At the same time, JavaScript is taking over more responsibility for building a website every day. The use of JavaScript is a hard thing to manage for web developers.</p><p>When you start building a website minimizing JavaScript should be the goal. That's even tougher, if not impossible when using a JavaScript framework. To help manage the amount of JavaScript rendered in the client, you can also render some of the JavaScript on the server. Creating that dynamic between client and server-side rendering can improve your LCP.</p><p>What server-sider rendering does is generating a completed HTML page on the server first. Then the HTML page is sent to the browser upon request. Then the browser executes a process called hydration to add all the JavaScript and required data onto that page's DOM content.</p><p>This process can help improve the pages LCP metrics but can cause errors in other areas such as:</p><ul><li>Managing server-side and client-side rendered JavaScript is rough (Look for future posts on my experience in this area)</li><li>The process of using JavaScript to build an HTML page first on the server will 100% increase the Time To First Byte metric.</li><li>It can also increase the Time to Interactive metric, because you are seperating the process of building DOM elimates and setting up the JS code to make them interactive.</li></ul><h4>There is also pre-rendering...</h4><p>Pre-rendering is less complicated than dividing up your site's code into client-side rendering and server-side rendering, and it's the process of building a static HTML page for every route. You'll run some JavaScript that will build each page, and you'll hear people refer to this process as &quot;build time.&quot;</p><p>During this &quot;build time&quot;, a bit of JavaScript code will build out a web page as users see it and interact with it. Meaning, all the CSS and client-side JS are baked into it. On top of building the page, that bit of JavaScript code will also minimize, set up preloading, and do all those things I described in this article about improving the LCP metrics.</p><p>Pre-rendering and generating your pages ahead of time is a great way to improve your LCP metrics. It's not a perfect solution because it affects other metrics negatively. However, pre-rendering is one of the best options, for now, until smarter people than I come up with a better solution.</p><h3>This was a long article. Why was it so long?</h3><p>This article is long and if you got this point and followed along, thank you! The biggest take-a-way here is that there are plenty of ways to improve the LCP metric in Google. What is not a take-a-way is that I made up all this myself, or these are my unique ideas. This article's content is my understanding and interpretation of this documentation <a href="https://web.dev/optimize-lcp/">Optimize Largest Contentful Paint</a>, which I declare is the source material for this article.</p><a href="/" class="my-4 text-1xl font-black text-green-800 flex md:justify-end underline">Back to home page</a></section></article></div><div class="max-w-screen-lg xl:max-w-screen-xl mx-auto"><section id="form" class="mt-10 max-w-screen-lg xl:max-w-screen-2xl mx-auto"><h3 class="text-left font-bold text-3xl text-gray-800 ml-6">Get in touch</h3><form class="flex flex-col w-100 md:w-3/5 my-8 mx-8 md:mx-auto pb-14" netlify><label class="sr-only" for="name">Name</label> <input id="name" type="text" name="name" placeholder="Full name" class="mt-4 p-2 border-2 border-green-700 focus:border-green-500 block w-100 text-base rounded-md"> <label class="sr-only" for="email">Email</label> <input id="email" type="email" name="email" placeholder="Email" class="mt-4 p-2 border-2 border-green-700 focus:border-green-500 block w-100 text-base rounded-md"> <label class="sr-only" for="phone">Phone</label> <input id="phone" type="phone" name="phone" placeholder="Phone" class="mt-4 p-2 border-2 border-green-700 focus:border-green-500 block w-100 text-base rounded-md"> <label class="sr-only" for="message">Message</label> <textarea id="message" rows="10" name="message" placeholder="Why you are reaching out..." class="mt-4 p-1 border-2 border-green-700 focus:border-green-500 block w-100 text-sm rounded-md"></textarea> <button class="focus:outline-none w-32 mt-5 py-2 rounded-md font-semibold text-white bg-green-800 ring-4 ring-green-300" type="submit">Send</button></form></section></div><footer class="w-100 flex mt-10 bg-gradient-to-t from-green-700 to-green-600 mx-0 bg-green-600"><p class="text-sm p-6 justify-start"><span class="text-white mr-4">Tumulty Web Services ©️ 2020</span> <a class="text-white mr-4" href="/sitemap.xml">Sitemap</a> <a class="text-white" href="https://github.com/Tumulty-Web-Services/tumultywebservices.dev">Source Code</a></p></footer></body></html>